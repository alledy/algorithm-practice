# [최대 자리곱](https://level.goorm.io/exam/49113/%EC%B5%9C%EB%8C%80-%EC%9E%90%EB%A6%AC%EA%B3%B1/quiz/1)

## 포인트
- 앞자리 수가 내려가면 뒷자리 수가 올라갈 가능성이 있다(eg. 38 -> 29)
- 그러므로 큰 자리수부터 해당 자리수를 -1하고 뒷 자리를 전부 9를 준다. 예를 들어 4876의 경우 아래처럼 총 4가지 경우의 수가 나온다. 
  - 4876(original)
  - 3999(0번째 인덱스 -1)
  - 4799(1번째 인덱스 -1)
  - 4869(2번째 인덱스 -1)
- 즉 N자리 수 숫자라면 N가지 수의 경우만 검토하면 된다. 
- 다만 이 과정을 코드로 짤 때 가장 걸림돌이 된건 **형변환**
  - i번째 인덱스의 값을 -1하고 싶으면, 해당 숫자에 인덱스로 접근할 수 있어야 한다는 뜻. 
  - int형은 인덱스 접근이 안된다. `'int' object is not subscriptable`이라는 에러가 난다. 
  - 즉 저런 접근을 하려면 이터러블인 str형으로 사용해야 한다는 것이다. 
  - 그래서 처음에는 str형에서 i번째 인덱스값에는 -1 한 다음, i-1 인덱스까지는 원래 값을 붙이고, 그 뒤의 인덱스 값에는 9를 주려고 했다.
  - 그러다 보니 1000 같은 케이스는, i가 0일 때, 0999가 되어 각 자리를 곱하면 0이 된다. 원래는 999가 되어야 하는데.:neutral_face: 
  - 또한 309 같은 케이스는 i가 1일 때 -1을 하면 3-19가 되어버린다(이렇게 되진 않고 중간에 에러남). 299가 되어야 하는데.:neutral_face:
  - 이런 자잘한 부분을 하드코딩하면 너무 지저분하기만 할 것 같아서, i번째 까지는 따로 뽑아서 Int형으로 바꾼 다음 -1하고, 다시 str로 형변환하기로 했다.
  - 그리고 1000 처럼, i번째 인덱스값을 -1하면 0이 되는 경우는 따로 if문으로 처리했다. 
  
## [풀이](./index.py)
