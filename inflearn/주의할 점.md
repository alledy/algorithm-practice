- 너무 많은 변수를 만들지 말 것
  굳이 필요한 경우가 아니라면 변수를 만드는 것을 재고해보아야 한다.
  변수가 많으면 관리하기 어렵고 헷갈리기 쉽다.

- 제일 먼저 생각하기. 무식하게(단순하게) 풀 수 있을까?

- 중복 순열, 그냥 순열
  depth -> 한 뎁스는 원소를 하나 뽑는 것을 의미한다
  그런데 이 한 뎁스 안에서 for문이 돌아야 한다. 왜냐하면 나는 0 depth에서 첫 번째 원소를 하나 뽑으려고 하는데,
  총 뽑을 수 있는 원소의 풀이 [1,2,3,4]라고 하면 그 원소는 1이 될 수도 2가 될 수도 3이 될 수도 4가 될 수도 있기 때문이다.
  그러므로 depth가 0일 때 이 4가지 경우를 모두 처리해줘야 하므로 풀을 for loop을 돌면 된다.

  다만 여기서 중복 순열과 그냥 순열의 차이가 생긴다.
  중복 순열의 경우 몇 번째 원소를 뽑더라도 pool이 항상 [1,2,3,4]로 같을 것이다. 1을 이미 첫번째 원소로 뽑았더라도, 2번째에 또 뽑아도 상관없기 때문이다.
  그러나 일반 수열에서는 1을 뽑고 나면 2번째 뽑을 수 있는 pool에는 1이 없어야 한다. 즉 [2,3,4]여야 한다.
  요 부분을 잘 고려해줘야 한다.

  일반 수열에서 내가 해본 것은 2가지 경우다.

  1. 빈 리스트에서 출발해서 append, pop 방식
  2. 길이가 정해진 리스트에서 해당 depth랑 인덱스를 매핑해서 뽑은 숫자를 원소로 덮어쓰는 방식

  첫 번째 방식의 경우 pool에서 for문을 돌면서 하나를 뽑고, 나머지 원소를 뽑는 과정을 재귀로 하기 위해 뽑고 난 나머지 pool을 재귀함수에 넘겨준다. 이 때에 자주 실수했던 것이, 나머지 pool을 rest라고 했을 때, pool.pop() 한 다음 그 pool을 재귀에 넘겨줬다는 것이다. 여기서 주의해야할 점은 pool을 변경시켜서 재귀함수에 넣으면 안된다는 것이다. 왜냐하면 재귀함수를 처리하고 나서 for문이 마저 돌텐데, 그 때의 pool은 이미 변경된 상태이다. 하지만 for문이 돌 때에는 항상 pool은 동일한 상태를 유지해야 한다. (말로 쓰니까 이상하지만🙉🙉🙉)
  예를 들어 첫 번째 원소를 뽑는 for loop에서 pool이 [1,2,3,4]라고 했을 때 아래처럼 한다면, 처음에 1을 뽑고 나머지 pool이 [2,3,4]가 된 상태에서 다음 루프를 돌면 [2,3,4]에서 하나를 뽑는게 되어버린다. 여기서 for은 depth가 일정한 상태이다.
  즉 첫번째 원소로 1을 뽑는 경우, 2를 뽑는 경우 ... 를 해보려 하는 것이므로 그 pool이 변경되면 안 된다는 것이다.
  그래서 picked도 다음 루프를 돌 때 아무 것도 안 뽑았던 상태로 되돌리기 위해 pop을 해주는 것이다.

  ```python
  # pool을 변경시키는 잘못된 예
  def permutation(picked,pool,d):
    # =======
    # 기저 조건
    # =======
    for i,x in enumerate(pool):
      picked.append(pool.pop(i))
      recursion(picked,pool,d+1)
      picked.pop()
  ```

  ```python
  # pool을 변경시키지 않는 예. 근데 rest_pool 구하는 걸 좀 더 개선해야 할 것 같다.
  def permutation(picked,pool,d):
    # =======
    # 기저 조건
    # =======
    for i in range(len(pool)):
      picked.append(pool[i])
      rest_pool = []
      for j in range(len(pool)):
        if i != j:
          rest_pool.append(pool[j])
      recursion(picked,rest_pool,d+1)
      picked.pop()
  ```

- 순열에서 append and pop? 또는 덮어쓰기? ([중복순열 구하기.py](./완전탐색/중복순열%20구하기.py) 참조)
  for문이 돌 때 pool이 불변이여야 한다. 그러므로 루프 안에서 append를 해줬으면 다음으로 넘어가기 전에 pop를 해서 그 상태를 유지해줘야 한다.
  그리고 덮어쓰기의 형태를 취했더라도, 여전히 내가 이미 뽑은 원소인지 아닌지를 체크하는 리스트가 하나 필요하다.
  이 리스트에 넣었다고 체크 표시를 해준 다음에 다시 다음 루프가 돌려면 체크 표시를 삭제해서 넣기 이전과 동일한 상태를 유지해야 한다. ([수열 추측하기.py](./완전탐색/수열%20추측하기.py) 참조)

- 원소 m개만 뽑는 경우 구하는 조합 vs 원소의 모든 조합
  원소의 모든 조합을 구해야할 경우 -> 2의 n승. 각각의 원소에 대해 뽑는 경우, 안 뽑는 경우를 가정하면 됨. ([최대 점수 구하기.py](./DFS,BFS/최대점수%20구하기.py))
  원소의 m개만 뽑는 경우는 depth로 기저 조건 설정하고(즉 뽑은 원소 개수) 각 depth마다 뽑을 수 있는 원소들의 집합으로 for loop 돌리면 됨. ([조합 구하기.py](./완전탐색/조합%20구하기.py))
  실수한 게, 모든 조합을 구해야되는 경우도 for loop으로 풀려고 했음. 이 경우 뽑아야 하는 원소 개수가 정해진 게 아니기 때문에 기저 조건 설정이 애매해짐.
  최대 depth를 채우거나, 또는 마지막 인덱스를 고른 경우로 해보려고 했는데, 만약 총 원소가 1,2,3 인경우 1,2,3 을 뽑고 다음에 1,3을 뽑아버림. 그리고 2,3으로 감.
  즉 1,2 같은 경우를 지나치므로 이 방식으로는 안됨.

- 재귀에서 같은 mutable object에 값을 계속 재할당하는 경우 주의
  배열에 값을 할당하면 그 배열은 계속 공유되는 객체이므로, 재귀를 통해서 depth가 올라갔다 내려갔다 한들 변한 상태는 그대로 적용되어 있다.
  즉 mutable object를 재귀에서 사용할 때 조심해야한다는 것. [동전 바꿔주기 문제](./DFS,BFS/동전%20바꿔주기.py)에서 그래서 숫자만 사용함.
  처음에는 list랑 dict 써서 하려다 보니 계속 위와 같은 문제가 있어서 문제를 잘 보니 굳이 몇 개씩 썼는지까지 알 필요 없는 문제였고, 그래서 이뮤터블한 원시값 사용.
